Prompt:
This is a very simple blog app to show how SvelteKit, LuciaAuth, Drizzle ORM with SQLite and tailwind can work toghether.


Here is all of the latest Drizzle ORM documentation, keep it in mind for my next questions:

Drizzle Queries
Drizzle ORM is designed to be a thin typed layer on top of SQL. We truly believe we’ve designed the best way to operate an SQL database from TypeScript and it’s time to make it better.

Relational queries are meant to provide you with a great developer experience for querying nested relational data from an SQL database, avoiding multiple joins and complex data mappings.

It is an extension to the existing schema definition and query builder. You can opt-in to use it based on your needs. We’ve made sure you have both the best-in-class developer experience and performance.


import * as schema from './schema';
import { drizzle } from 'drizzle-orm/...';
const db = drizzle(client, { schema });
const result = await db.query.users.findMany({
  with: {
    posts: true      
  },
});
[{
  id: 10,
  name: "Dan",
  posts: [
    {
      id: 1,
      content: "SQL is awesome",
      authorId: 10,
    },
    {
      id: 2,
      content: "But check relational queries",
      authorId: 10,
    }
  ]
}]
⚠️ If you have SQL schema declared in multiple files you can do it like that


import * as schema1 from './schema1';
import * as schema2 from './schema2';
import { drizzle } from 'drizzle-orm/...';
const db = drizzle(client, { schema: { ...schema1, ...schema2 } });
const result = await db.query.users.findMany({
  with: {
    posts: true      
  },
});
Modes
Drizzle relational queries always generate exactly one SQL statement to run on the database and it has certain caveats. To have best in class support for every database out there we’ve introduced modes.

Drizzle relational queries use lateral joins of subqueries under the hood and for now PlanetScale does not support them.

When using mysql2 driver with regular MySQL database — you should specify mode: "default" When using mysql2 driver with PlanetScale — you need to specify mode: "planetscale"


import * as schema from './schema';
import { drizzle } from "drizzle-orm/mysql2";
import mysql from "mysql2/promise";
const connection = await mysql.createConnection({
  uri: process.env.PLANETSCALE_DATABASE_URL,
});
const db = drizzle(connection, { schema, mode: 'planetscale' });
Declaring relations
One-to-one
Drizzle ORM provides you an API to define one-to-one relations between tables with the relations operator.

An example of a one-to-one relation between users and users, where a user can invite another (this example uses a self reference):


import { pgTable, serial, text, integer, boolean } from 'drizzle-orm/pg-core';
import { relations } from 'drizzle-orm';
export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  name: text('name'),
  invitedBy: integer('invited_by'),
});
export const usersRelations = relations(users, ({ one }) => ({
  invitee: one(users, {
    fields: [users.invitedBy],
    references: [users.id],
  }),
}));
Another example would be a user having a profile information stored in separate table. In this case, because the foreign key is stored in the “profile_info” table, the user relation have neither fields or references. This tells Typescript that user.profileInfo is nullable:


import { pgTable, serial, text, integer, jsonb } from 'drizzle-orm/pg-core';
import { relations } from 'drizzle-orm';
export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  name: text('name'),
});
export const usersRelations = relations(users, ({ one }) => ({
  profileInfo: one(profileInfo),
}));
export const profileInfo = pgTable('profile_info', {
  id: serial('id').primaryKey(),
  userId: integer('user_id').references(() => users.id),
  metadata: jsonb('metadata'),
});
export const profileInfoRelations = relations(profileInfo, ({ one }) => ({
  user: one(users, { fields: [profileInfo.userId], references: [users.id] }),
}));
const user = await queryUserWithProfileInfo();
//____^? type { id: number, profileInfo: { ... } | null  }
One-to-many
Drizzle ORM provides you an API to define one-to-many relations between tables with relations operator.

Example of one-to-many relation between users and posts they’ve written:


import { pgTable, serial, text, integer } from 'drizzle-orm/pg-core';
import { relations } from 'drizzle-orm';
export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  name: text('name'),
});
export const usersRelations = relations(users, ({ many }) => ({
  posts: many(posts),
}));
export const posts = pgTable('posts', {
  id: serial('id').primaryKey(),
  content: text('content'),
  authorId: integer('author_id'),
});
export const postsRelations = relations(posts, ({ one }) => ({
  author: one(users, {
    fields: [posts.authorId],
    references: [users.id],
  }),
}));
Now lets add comments to the posts:


...
export const posts = pgTable('posts', {
  id: serial('id').primaryKey(),
  content: text('content'),
  authorId: integer('author_id'),
});
export const postsRelations = relations(posts, ({ one, many }) => ({
  author: one(users, {
    fields: [posts.authorId],
    references: [users.id],
  }),
  comments: many(comments)
}));
export const comments = pgTable('comments', {
  id: serial('id').primaryKey(),
  text: text('text'),
  authorId: integer('author_id'),
  postId: integer('post_id'),
});
export const commentsRelations = relations(comments, ({ one }) => ({
  post: one(posts, {
    fields: [comments.postId],
    references: [posts.id],
  }),
}));
Many-to-many
Drizzle ORM provides you an API to define many-to-many relations between tables through so called junction or join tables, they have to be explicitly defined and store associations between related tables.

Example of many-to-many relation between users and groups:


import { relations } from 'drizzle-orm';
import { integer, pgTable, primaryKey, serial, text } from 'drizzle-orm/pg-core';
export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  name: text('name'),
});
export const usersRelations = relations(users, ({ many }) => ({
  usersToGroups: many(usersToGroups),
}));
export const groups = pgTable('groups', {
  id: serial('id').primaryKey(),
  name: text('name'),
});
export const groupsRelations = relations(groups, ({ many }) => ({
  usersToGroups: many(usersToGroups),
}));
export const usersToGroups = pgTable(
  'users_to_groups',
  {
    userId: integer('user_id')
      .notNull()
      .references(() => users.id),
    groupId: integer('group_id')
      .notNull()
      .references(() => groups.id),
  },
  (t) => ({
    pk: primaryKey({ columns: [t.userId, t.groupId] }),
  }),
);
export const usersToGroupsRelations = relations(usersToGroups, ({ one }) => ({
  group: one(groups, {
    fields: [usersToGroups.groupId],
    references: [groups.id],
  }),
  user: one(users, {
    fields: [usersToGroups.userId],
    references: [users.id],
  }),
}));
Foreign keys
You might’ve noticed that relations look similar to foreign keys — they even have a references property. So what’s the difference?

While foreign keys serve a similar purpose, defining relations between tables, they work on a different level compared to relations.

Foreign keys are a database level constraint, they are checked on every insert/update/delete operation and throw an error if a constraint is violated. On the other hand, relations are a higher level abstraction, they are used to define relations between tables on the application level only. They do not affect the database schema in any way and do not create foreign keys implicitly.

What this means is relations and foreign keys can be used together, but they are not dependent on each other. You can define relations without using foreign keys (and vice versa), which allows them to be used with databases that do not support foreign keys.

The following two examples will work exactly the same in terms of querying the data using Drizzle relational queries.

export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  name: text('name'),
});
export const usersRelations = relations(users, ({ one, many }) => ({
  profileInfo: one(users, {
    fields: [profileInfo.userId],
    references: [users.id],
  }),
}));
export const profileInfo = pgTable('profile_info', {
  id: serial('id').primaryKey(),
  userId: integer("user_id"),
  metadata: jsonb("metadata"),
});
Foreign key actions
for more information check postgres foreign keys docs

You can specify actions that should occur when the referenced data in the parent table is modified. These actions are known as “foreign key actions.” PostgreSQL provides several options for these actions.

On Delete/ Update Actions

CASCADE: When a row in the parent table is deleted, all corresponding rows in the child table will also be deleted. This ensures that no orphaned rows exist in the child table.

NO ACTION: This is the default action. It prevents the deletion of a row in the parent table if there are related rows in the child table. The DELETE operation in the parent table will fail.

RESTRICT: Similar to NO ACTION, it prevents the deletion of a parent row if there are dependent rows in the child table. It is essentially the same as NO ACTION and included for compatibility reasons.

SET DEFAULT: If a row in the parent table is deleted, the foreign key column in the child table will be set to its default value if it has one. If it doesn’t have a default value, the DELETE operation will fail.

SET NULL: When a row in the parent table is deleted, the foreign key column in the child table will be set to NULL. This action assumes that the foreign key column in the child table allows NULL values.

Analogous to ON DELETE there is also ON UPDATE which is invoked when a referenced column is changed (updated). The possible actions are the same, except that column lists cannot be specified for SET NULL and SET DEFAULT. In this case, CASCADE means that the updated values of the referenced column(s) should be copied into the referencing row(s). in drizzle you can add foreign key action using references() second argument.

type of the actions

export type UpdateDeleteAction = 'cascade' | 'restrict' | 'no action' | 'set null' | 'set default';
// second argument of references interface
actions?: {
    onUpdate?: UpdateDeleteAction;
    onDelete?: UpdateDeleteAction;
  } | undefined
In the following example, adding onDelete: 'cascade' to the author field on the posts schema means that deleting the user will also delete all related Post records.

import { pgTable, serial, text, integer } from 'drizzle-orm/pg-core';
export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  name: text('name'),
});
export const posts = pgTable('posts', {
  id: serial('id').primaryKey(),
  name: text('name'),
  author: integer('author').references(() => users.id, {onDelete: 'cascade'}).notNull(),
});
For constraints specified with the foreignKey operator, foreign key actions are defined with the syntax:

import { foreignKey, pgTable, serial, text, integer } from 'drizzle-orm/pg-core';
export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  name: text('name'),
});
export const posts = pgTable('posts', {
  id: serial('id').primaryKey(),
  name: text('name'),
  author: integer('author').notNull(),
}, (table) => ({
    fk: foreignKey({
      name: "author_fk",
      columns: [table.author],
      foreignColumns: [users.id],
    })
      .onDelete('cascade')
      .onUpdate('cascade')
  }),
);
Disambiguating relations
Drizzle also provides the relationName option as a way to disambiguate relations when you define multiple of them between the same two tables. For example, if you define a posts table that has the author and reviewer relations.

import { pgTable, serial, text, integer } from 'drizzle-orm/pg-core';
import { relations } from 'drizzle-orm';
 
export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  name: text('name'),
});
 
export const usersRelations = relations(users, ({ many }) => ({
  author: many(posts, { relationName: 'author' }),
  reviewer: many(posts, { relationName: 'reviewer' }),
}));
 
export const posts = pgTable('posts', {
  id: serial('id').primaryKey(),
  content: text('content'),
  authorId: integer('author_id'),
  reviewerId: integer('reviewer_id'),
});
 
export const postsRelations = relations(posts, ({ one }) => ({
  author: one(users, {
    fields: [posts.authorId],
    references: [users.id],
    relationName: 'author',
  }),
  reviewer: one(users, {
    fields: [posts.reviewerId],
    references: [users.id],
    relationName: 'reviewer',
  }),
}));
Querying
Relational queries are an extension to Drizzle’s original query builder. You need to provide all tables and relations from your schema file/files upon drizzle() initialization and then just use the db.query API.

drizzle import path depends on the database driver you’re using.

import * as schema from './schema';
import { drizzle } from 'drizzle-orm/...';
const db = drizzle(client, { schema });
await db.query.users.findMany(...);
// if you have schema in multiple files
import * as schema1 from './schema1';
import * as schema2 from './schema2';
import { drizzle } from 'drizzle-orm/...';
const db = drizzle(client, { schema: { ...schema1, ...schema2 } });
await db.query.users.findMany(...);
Drizzle provides .findMany() and .findFirst() APIs.

Find many

const users = await db.query.users.findMany();
// result type
const result: {
  id: number;
  name: string;
  verified: boolean;
  invitedBy: number | null;
}[];
Find first
.findFirst() will add limit 1 to the query.


const user = await db.query.users.findFirst();
// result type
const result: {
  id: number;
  name: string;
  verified: boolean;
  invitedBy: number | null;
};
Include relations
With operator lets you combine data from multiple related tables and properly aggregate results.

Getting all posts with comments:


const posts = await db.query.posts.findMany({
  with: {
    comments: true,
  },
});
Getting first post with comments:


const post = await db.query.posts.findFirst({
  with: {
    comments: true,
  },
});
You can chain nested with statements as much as necessary.
For any nested with queries Drizzle will infer types using Core Type API.

Get all users with posts. Each post should contain a list of comments:


const users = await db.query.users.findMany({
  with: {
    posts: {
      with: {
        comments: true,
      },
    },
  },
});
Partial fields select
columns parameter lets you include or omit columns you want to get from the database.

Drizzle performs partial selects on the query level, no additional data is transferred from the database.

Keep in mind that a single SQL statement is outputted by Drizzle.

Get all posts with just id, content and include comments:


const posts = await db.query.posts.findMany({
  columns: {
    id: true,
    content: true,
  },
  with: {
    comments: true,
  }
});
Get all posts without content:


const posts = await db.query.posts.findMany({
  columns: {
    content: false,
  },
});
When both true and false select options are present, all false options are ignored.

If you include the name field and exclude the id field, id exclusion will be redundant, all fields apart from name would be excluded anyways.

Exclude and Include fields in the same query:


const users = await db.query.users.findMany({
  columns: {
    name: true,
    id: false //ignored
  },
});
// result type
const users: {
  name: string;
};
Only include columns from nested relations:


const res = await db.query.users.findMany({
  columns: {},
  with: {
    posts: true
  }
});
// result type
const res: {
  posts: {
    id: number,
    text: string
  }
}[];
Nested partial fields select
Just like with partial select, you can include or exclude columns of nested relations:


const posts = await db.query.posts.findMany({
  columns: {
    id: true,
    content: true,
  },
  with: {
    comments: {
      columns: {
        authorId: false
      }
    }
  }
});
Select filters
Just like in our SQL-like query builder, relational queries API lets you define filters and conditions with the list of our operators.

You can either import them from drizzle-orm or use from the callback syntax:


import { eq } from 'drizzle-orm';
const users = await db.query.users.findMany({
  where: eq(users.id, 1)
})

const users = await db.query.users.findMany({
  where: (users, { eq }) => eq(users.id, 1),
})
Find post with id=1 and comments that were created before particular date:


await db.query.posts.findMany({
  where: (posts, { eq }) => (eq(posts.id, 1)),
  with: {
    comments: {
      where: (comments, { lt }) => lt(comments.createdAt, new Date()),
    },
  },
});
Limit & Offset
Drizzle ORM provides limit & offset API for queries and for the nested entities.

Find 5 posts:


await db.query.posts.findMany({
  limit: 5,
});
Find posts and get 3 comments at most:


await db.query.posts.findMany({
  with: {
    comments: {
      limit: 3,
    },
  },
});
offset is only available for top level query.

await db.query.posts.findMany({
  limit: 5,
  offset: 2, // correct ✅
  with: {
    comments: {
      offset: 3, // incorrect ❌
      limit: 3,
    },
  },
});
Find posts with comments from the 5th to the 10th post:


await db.query.posts.findMany({
  limit: 5,
  offset: 5,
  with: {
    comments: true,
  },
});
Order By
Drizzle provides API for ordering in the relational query builder.

You can use same ordering core API or use order by operator from the callback with no imports.


import { desc, asc } from 'drizzle-orm';
await db.query.posts.findMany({
  orderBy: [asc(posts.id)],
});

await db.query.posts.findMany({
  orderBy: (posts, { asc }) => [asc(posts.id)],
});
Order by asc + desc:


await db.query.posts.findMany({
  orderBy: (posts, { asc }) => [asc(posts.id)],
  with: {
    comments: {
      orderBy: (comments, { desc }) => [desc(comments.id)],
    },
  },
});
Include custom fields
Relational query API lets you add custom additional fields. It’s useful when you need to retrieve data and apply additional functions to it.

As of now aggregations are not supported in extras, please use core queries for that.


import { sql } from 'drizzle-orm';
await db.query.users.findMany({
  extras: {
    loweredName: sql`lower(${users.name})`.as('lowered_name'),
  },
})

await db.query.users.findMany({
  extras: {
    loweredName: (users, { sql }) => sql`lower(${users.name})`.as('lowered_name'),
  },
})
lowerName as a key will be included to all fields in returned object.

You have to explicitly specify .as("<name_for_column>")

To retrieve all users with groups, but with the fullName field included (which is a concatenation of firstName and lastName), you can use the following query with the Drizzle relational query builder.


const res = await db.query.users.findMany({
  extras: {
    fullName: sql<string>`concat(${users.name}, " ", ${users.name})`.as('full_name'),
  },
  with: {
    usersToGroups: {
      with: {
        group: true,
      },
    },
  },
});
// result type
const res: {
  id: number;
  name: string;
  verified: boolean;
  invitedBy: number | null;
  fullName: string;
  usersToGroups: {
      group: {
          id: number;
          name: string;
          description: string | null;
      };
  }[];
}[];
To retrieve all posts with comments and add an additional field to calculate the size of the post content and the size of each comment content:


const res = await db.query.posts.findMany({
  extras: (table, { sql }) => ({
    contentLength: (sql<number>`length(${table.content})`).as('content_length'),
  }),
  with: {
    comments: {
      extras: {
        commentSize: sql<number>`length(${comments.content})`.as('comment_size'),
      },
    },
  },
});
// result type
const res: {
  id: number;
  createdAt: Date;
  content: string;
  authorId: number | null;
  contentLength: number;
  comments: {
      id: number;
      createdAt: Date;
      content: string;
      creator: number | null;
      postId: number | null;
      commentSize: number;
  }[];
};
Prepared statements
Prepared statements are designed to massively improve query performance — see here.

In this section, you can learn how to define placeholders and execute prepared statements using the Drizzle relational query builder.

Placeholder in where

const prepared = db.query.users.findMany({
  where: ((users, { eq }) => eq(users.id, placeholder('id'))),
  with: {
    posts: {
      where: ((users, { eq }) => eq(users.id, 1)),
    },
  },
}).prepare('query_name');
const usersWithPosts = await prepared.execute({ id: 1 });
Placeholder in limit

const prepared = db.query.users.findMany({
  with: {
    posts: {
      limit: placeholder('limit'),
    },
  },
}).prepare('query_name');
const usersWithPosts = await prepared.execute({ limit: 1 });
Placeholder in offset

const prepared = db.query.users.findMany({
  offset: placeholder('offset'),
  with: {
    posts: true,
  },
}).prepare('query_name');
const usersWithPosts = await prepared.execute({ offset: 1 });
Multiple placeholders

const prepared = db.query.users.findMany({
  limit: placeholder('uLimit'),
  offset: placeholder('uOffset'),
  where: ((users, { eq, or }) => or(eq(users.id, placeholder('id')), eq(users.id, 3))),
  with: {
    posts: {
      where: ((users, { eq }) => eq(users.id, placeholder('pid'))),
      limit: placeholder('pLimit'),
    },
  },
}).prepare('query_name');
const usersWithPosts = await prepared.execute({ pLimit: 1, uLimit: 3, uOffset: 1, id: 2, pid: 6 });


SQL Select
Drizzle provides you the most SQL-like way to fetch data from your database, while remaining type-safe and composable. It natively supports mostly every query feature and capability of every dialect, and whatever it doesn’t support yet, can be added by the user with the powerful sql operator.

For the following examples, let’s assume you have a users table defined like this:

import { pgTable, serial, text } from 'drizzle-orm/pg-core';
export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
  age: integer('age'),
});
Basic and partial select
Select with all columns
Select all rows from a table including all columns:

const result = await db.select().from(users);
/*
  {
    id: number;
    name: string;
    age: number | null;
  }[]
*/
select "id", "name", "age" from "users";
Notice that the result type is inferred automatically based on the table definition, including columns nullability.

Drizzle always explicitly lists columns in the select clause instead of using select *.
This is required internally to guarantee the fields order in the query result, and is also generally considered a good practice.

Partial select
In some cases, you might want to select only a subset of columns from a table. You can do that by providing a selection object to the .select() method:


const result = await db.select({
  field1: users.id,
  field2: users.name,
}).from(users);
const { field1, field2 } = result[0];
select "id", "name" from "users";
Like in SQL, you can use arbitrary expressions as selection fields, not just table columns:

const result = await db.select({
  id: users.id,
  lowerName: sql<string>`lower(${users.name})`,
}).from(users);
select "id", lower("name") from "users";
By specifying sql<string>, you are telling Drizzle that the expected type of the field is string.
If you specify it incorrectly (e.g. use sql<number> for a field that will be returned as a string), the runtime value won’t match the expected type. Drizzle cannot perform any type casts based on the provided type generic, because that information is not available at runtime.

If you need to apply runtime transformations to the returned value, you can use the .mapWith() method.

If you have an expression you use frequently, you can extract it into a function:

import type { Column } from 'drizzle-orm';
import { sql } from 'drizzle-orm';
function lower(col: Column) {
  return sql<string>`lower(${col})`;
}
const result = await db.select({
  id: users.id,
  lowerName: lower(users.name),
}).from(users);
Conditional select
You can have a dynamic selection object based on some condition:

async function selectUsers(withName: boolean) {
  return db
    .select({
      id: users.id,
      ...(withName ? { name: users.name } : {}),
    })
    .from(users);
}
const users = await selectUsers(true);
Filtering
You can filter the query results using the filter operators in the .where() method:


import { eq, lt, gte, ne } from 'drizzle-orm';
await db.select().from(users).where(eq(users.id, 42));
await db.select().from(users).where(lt(users.id, 42));
await db.select().from(users).where(gte(users.id, 42));
await db.select().from(users).where(ne(users.id, 42));
...
select "id", "name", "age" from "users" where "id" = 42;
select "id", "name", "age" from "users" where "id" < 42;
select "id", "name", "age" from "users" where "id" >= 42;
select "id", "name", "age" from "users" where "id" <> 42;
All filter operators are implemented using the sql function. You can use it yourself to write arbitrary SQL filters, or build your own operators. For inspiration, you can check how the operators provided by Drizzle are implemented.


import { sql } from 'drizzle-orm';
function equals42(col: Column) {
  return sql`${col} = 42`;
}
await db.select().from(users).where(sql`${users.id} < 42`);
await db.select().from(users).where(sql`${users.id} = 42`);
await db.select().from(users).where(equals42(users.id));
await db.select().from(users).where(sql`${users.id} >= 42`);
await db.select().from(users).where(sql`${users.id} <> 42`);
await db.select().from(users).where(sql`lower(${users.name}) = 'aaron'`);
select "id", "name", "age" from "users" where 'id' < 42;
select "id", "name", "age" from "users" where 'id' = 42;
select "id", "name", "age" from "users" where 'id' = 42;
select "id", "name", "age" from "users" where 'id' >= 42;
select "id", "name", "age" from "users" where 'id' <> 42;
select "id", "name", "age" from "users" where lower("name") = 'aaron';
All the values provided to filter operators and to the sql function are parameterized automatically. For example, this query:

await db.select().from(users).where(eq(users.id, 42));
will be translated to:

select "id", "name", "age" from "users" where "id" = $1; -- params: [42]
Inverting condition with a not operator:


import { eq, not, sql } from 'drizzle-orm';
await db.select().from(users).where(not(eq(users.id, 42)));
await db.select().from(users).where(sql`not ${users.id} = 42`);
select "id", "name", "age" from "users" where not ("id" = 42);
select "id", "name", "age" from "users" where not ("id" = 42);
You can safely alter schema, rename tables and columns and it will be automatically reflected in your queries because of template interpolation, as opposed to hardcoding column or table names when writing raw SQL.

Combining filters
You can logically combine filter operators with and() and or() operators:


import { eq, and, sql } from 'drizzle-orm';
await db.select().from(users).where(
  and(
    eq(users.id, 42),
    eq(users.name, 'Dan')
  )
);
await db.select().from(users).where(sql`${users.id} = 42 and ${users.name} = 'Dan'`);
select "id", "name", "age" from "users" where "id" = 42 and "name" = 'Dan';
select "id", "name", "age" from "users" where "id" = 42 and "name" = 'Dan';

import { eq, or, sql } from 'drizzle-orm';
await db.select().from(users).where(
  or(
    eq(users.id, 42), 
    eq(users.name, 'Dan')
  )
);
await db.select().from(users).where(sql`${users.id} = 42 or ${users.name} = 'Dan'`);
select "id", "name", "age" from "users" where "id" = 42 or "name" = 'Dan';
select "id", "name", "age" from "users" where "id" = 42 or "name" = 'Dan';
Distinct
You can use .selectDistinct() instead of .select() to retrieve only unique rows from a dataset:

await db.selectDistinct().from(users).orderBy(usersTable.id, usersTable.name);
await db.selectDistinct({ id: users.id }).from(users).orderBy(usersTable.id);
select distinct "id", "name" from "users" order by "id", "name";
select distinct "id" from "users" order by "id";
In PostgreSQL, you can also use the distinct on clause to specify how the unique rows are determined:

await db.selectDistinctOn([users.id]).from(users).orderBy(users.id);
await db.selectDistinctOn([users.name], { name: users.name }).from(users).orderBy(users.name);
select distinct on ("id") "id", "name" from "users" order by "id";
select distinct on ("name") "name" from "users" order by "name";
distinct on clause is only supported in PostgreSQL.

Limit & offset
Use .limit() and .offset() to add limit and offset clauses to the query - for example, to implement pagination:

await db.select().from(users).limit(10);
await db.select().from(users).limit(10).offset(10);
select "id", "name", "age" from "users" limit 10;
select "id", "name", "age" from "users" limit 10 offset 10;
Order By
Use .orderBy() to add order by clause to the query, sorting the results by the specified fields:

import { asc, desc } from 'drizzle-orm';
await db.select().from(users).orderBy(users.name);
await db.select().from(users).orderBy(desc(users.name));
// order by multiple fields
await db.select().from(users).orderBy(users.name, users.name2);
await db.select().from(users).orderBy(asc(users.name), desc(users.name2));
select "id", "name", "age" from "users" order by "name";
select "id", "name", "age" from "users" order by "name" desc;
select "id", "name", "age" from "users" order by "name", "name2";
select "id", "name", "age" from "users" order by "name" asc, "name2" desc;
WITH clause
Check how to use WITH statement with insert, update, delete

Using the with clause can help you simplify complex queries by splitting them into smaller subqueries called common table expressions (CTEs):


const sq = db.$with('sq').as(db.select().from(users).where(eq(users.id, 42)));
const result = await db.with(sq).select().from(sq);
with sq as (select "id", "name", "age" from "users" where "id" = 42)
select "id", "name", "age" from sq;
To select arbitrary SQL values as fields in a CTE and reference them in other CTEs or in the main query, you need to add aliases to them:


const sq = db.$with('sq').as(db.select({ 
  name: sql<string>`upper(${users.name})`.as('name'),
})
.from(users));
const result = await db.with(sq).select({ name: sq.name }).from(sq);
If you don’t provide an alias, the field type will become DrizzleTypeError and you won’t be able to reference it in other queries. If you ignore the type error and still try to use the field, you will get a runtime error, since there’s no way to reference that field without an alias.

Select from subquery
Just like in SQL, you can embed queries into other queries by using the subquery API:


const sq = db.select().from(users).where(eq(users.id, 42)).as('sq');
const result = await db.select().from(sq);
select "id", "name", "age" from (select "id", "name", "age" from "users" where "id" = 42) "sq";
Subqueries can be used in any place where a table can be used, for example in joins:


const sq = db.select().from(users).where(eq(users.id, 42)).as('sq');
const result = await db.select().from(users).leftJoin(sq, eq(users.id, sq.id));
select "users"."id", "users"."name", "users"."age", "sq"."id", "sq"."name", "sq"."age" from "users"
  left join (select "id", "name", "age" from "users" where "id" = 42) "sq"
    on "users"."id" = "sq"."id";
Iterator
MySQL
PostgreSQL[WIP]
SQLite[WIP]
If you need to return a very large amount of rows from a query and you don’t want to load them all into memory, you can use .iterator() to convert the query into an async iterator:


const iterator = await db.select().from(users).iterator();
for await (const row of iterator) {
  console.log(row);
}
It also works with prepared statements:


const query = await db.select().from(users).prepare();
const iterator = await query.iterator();
for await (const row of iterator) {
  console.log(row);
}
Aggregations
With Drizzle, you can do aggregations using functions like sum, count, avg, etc. by grouping and filtering with .groupBy() and .having() respectfully, same as you would do in raw SQL:

import { gt } from 'drizzle-orm';
await db.select({
  age: users.age,
  count: sql<number>`cast(count(${users.id}) as int)`,
})
  .from(users)
  .groupBy(users.age);
await db.select({
  age: users.age,
  count: sql<number>`cast(count(${users.id}) as int)`,
})
  .from(users)
  .groupBy(users.age)
  .having(({ count }) => gt(count, 1));
select "age", cast(count("id") as int)
  from "users"
  group by "age";
select "age", cast(count("id") as int)
  from "users"
  group by "age"
  having cast(count("id") as int) > 1;
cast(... as int) is necessary because count() returns bigint in PostgreSQL and decimal in MySQL, which are treated as string values instead of numbers. Alternatively, you can use .mapWith(Number) to cast the value to a number at runtime.

Aggregations helpers
Drizzle has a set of wrapped sql functions, so you don’t need to write sql templates for common cases in your app

Remember, aggregation functions are often used with the GROUP BY clause of the SELECT statement. So if you are selecting using aggregating functions and other columns in one query, be sure to use the .groupBy clause

count

Returns the number of values in expression.

import { count } from 'drizzle-orm'
await db.select({ value: count() }).from(users);
await db.select({ value: count(users.id) }).from(users);
select count("*") from "users";
select count("id") from "users";
// It's equivalent to writing
await db.select({ 
  value: sql`count('*'))`.mapWith(Number) 
}).from(users);
await db.select({ 
  value: sql`count(${users.id})`.mapWith(Number) 
}).from(users);
countDistinct

Returns the number of non-duplicate values in expression.

import { countDistinct } from 'drizzle-orm'
await db.select({ value: countDistinct(users.id) }).from(users);
select count(distinct "id") from "users";
// It's equivalent to writing
await db.select({ 
  value: sql`count(${users.id})`.mapWith(Number) 
}).from(users);
avg

Returns the average (arithmetic mean) of all non-null values in expression.

import { avg } from 'drizzle-orm'
await db.select({ value: avg(users.id) }).from(users);
select avg("id") from "users";
// It's equivalent to writing
await db.select({ 
  value: sql`avg(${users.id})`.mapWith(String) 
}).from(users);
avgDistinct

Returns the average (arithmetic mean) of all non-null values in expression.

import { avgDistinct } from 'drizzle-orm'
await db.select({ value: avgDistinct(users.id) }).from(users);
select avg(distinct "id") from "users";
// It's equivalent to writing
await db.select({ 
  value: sql`avg(distinct ${users.id})`.mapWith(String) 
}).from(users);
sum

Returns the sum of all non-null values in expression.

import { sum } from 'drizzle-orm'
await db.select({ value: sum(users.id) }).from(users);
select sum("id") from "users";
// It's equivalent to writing
await db.select({ 
  value: sql`sum(${users.id})`.mapWith(String) 
}).from(users);
sumDistinct

Returns the sum of all non-null and non-duplicate values in expression.

import { sumDistinct } from 'drizzle-orm'
await db.select({ value: sumDistinct(users.id) }).from(users);
select sum(distinct "id") from "users";
// It's equivalent to writing
await db.select({ 
  value: sql`sum(distinct ${users.id})`.mapWith(String) 
}).from(users);
max

Returns the maximum value in expression.

import { max } from 'drizzle-orm'
await db.select({ value: max(users.id) }).from(users);
select max("id") from "users";
// It's equivalent to writing
await db.select({ 
  value: sql`max(${expression})`.mapWith(users.id) 
}).from(users);
min

Returns the minimum value in expression.

import { min } from 'drizzle-orm'
await db.select({ value: min(users.id) }).from(users);
select min("id") from "users";
// It's equivalent to writing
await db.select({ 
  value: sql`min(${users.id})`.mapWith(users.id) 
}).from(users);
A more advanced example:


const orders = sqliteTable('order', {
  id: integer('id').primaryKey(),
  orderDate: integer('order_date', { mode: 'timestamp' }).notNull(),
  requiredDate: integer('required_date', { mode: 'timestamp' }).notNull(),
  shippedDate: integer('shipped_date', { mode: 'timestamp' }),
  shipVia: integer('ship_via').notNull(),
  freight: numeric('freight').notNull(),
  shipName: text('ship_name').notNull(),
  shipCity: text('ship_city').notNull(),
  shipRegion: text('ship_region'),
  shipPostalCode: text('ship_postal_code'),
  shipCountry: text('ship_country').notNull(),
  customerId: text('customer_id').notNull(),
  employeeId: integer('employee_id').notNull(),
});
const details = sqliteTable('order_detail', {
  unitPrice: numeric('unit_price').notNull(),
  quantity: integer('quantity').notNull(),
  discount: numeric('discount').notNull(),
  orderId: integer('order_id').notNull(),
  productId: integer('product_id').notNull(),
});
db
  .select({
    id: orders.id,
    shippedDate: orders.shippedDate,
    shipName: orders.shipName,
    shipCity: orders.shipCity,
    shipCountry: orders.shipCountry,
    productsCount: sql<number>`cast(count(${details.productId}) as int)`,
    quantitySum: sql<number>`sum(${details.quantity})`,
    totalPrice: sql<number>`sum(${details.quantity} * ${details.unitPrice})`,
  })
  .from(orders)
  .leftJoin(details, eq(orders.id, details.orderId))
  .groupBy(orders.id)
  .orderBy(asc(orders.id))
  .all();



  SQL Insert
Drizzle ORM provides you the most SQL-like way to insert rows into the database tables.

Insert one row
Inserting data with Drizzle is extremely straightfoward and sql-like. See for yourself:


await db.insert(users).values({ name: 'Andrew' });
insert into "users" ("name") values ("Andrew");
If you need insert type for a particular table you can use typeof usersTable.$inferInsert syntax.


type NewUser = typeof users.$inferInsert;
const insertUser = async (user: NewUser) => {
  return db.insert(users).values(user);
}
const newUser: NewUser = { name: "Alef" };
await insertUser(newUser);
Insert returning
PostgreSQL
SQLite
MySQL
You can insert a row and get it back in PostgreSQL and SQLite like such:


await db.insert(users).values({ name: "Dan" }).returning();
// partial return
await db.insert(users).values({ name: "Partial Dan" }).returning({ insertedId: users.id });
Insert $returningId
PostgreSQL
SQLite
MySQL
MySQL itself doesn’t have native support for RETURNING after using INSERT. There is only one way to do it for primary keys with autoincrement (or serial) types, where you can access insertId and affectedRows fields. We’ve prepared an automatic way for you to handle such cases with Drizzle and automatically receive all inserted IDs as separate objects

import { boolean, int, text, mysqlTable } from 'drizzle-orm/mysql-core';
const usersTable = mysqlTable('users', {
  id: int('id').primaryKey(),
  name: text('name').notNull(),
  verified: boolean('verified').notNull().default(false),
});
const result = await db.insert(usersTable).values([{ name: 'John' }, { name: 'John1' }]).$returningId();
//    ^? { id: number }[]
Also with Drizzle, you can specify a primary key with $default function that will generate custom primary keys at runtime. We will also return those generated keys for you in the $returningId() call

import { varchar, text, mysqlTable } from 'drizzle-orm/mysql-core';
import { createId } from '@paralleldrive/cuid2';
const usersTableDefFn = mysqlTable('users_default_fn', {
  customId: varchar('id', { length: 256 }).primaryKey().$defaultFn(createId),
  name: text('name').notNull(),
});
const result = await db.insert(usersTableDefFn).values([{ name: 'John' }, { name: 'John1' }]).$returningId();
//  ^? { customId: string }[]
If there is no primary keys -> type will be {}[] for such queries

Insert multiple rows

await db.insert(users).values([{ name: 'Andrew' }, { name: 'Dan' }]);
Upserts and conflicts
Drizzle ORM provides simple interfaces for handling upserts and conflicts.

On conflict do nothing
PostgreSQL
SQLite
MySQL
onConflictDoNothing will cancel the insert if there’s a conflict:


await db.insert(users)
  .values({ id: 1, name: 'John' })
  .onConflictDoNothing();
// explicitly specify conflict target
await db.insert(users)
  .values({ id: 1, name: 'John' })
  .onConflictDoNothing({ target: users.id });
On conflict do update
PostgreSQL
SQLite
MySQL
onConflictDoUpdate will update the row if there’s a conflict:

await db.insert(users)
  .values({ id: 1, name: 'Dan' })
  .onConflictDoUpdate({ target: users.id, set: { name: 'John' } });
where clauses
on conflict do update can have a where clause in two different places - as part of the conflict target (i.e. for partial indexes) or as part of the update clause:

insert into employees (employee_id, name)
values (123, 'John Doe')
on conflict (employee_id) where name <> 'John Doe'
do update set name = excluded.name
insert into employees (employee_id, name)
values (123, 'John Doe')
on conflict (employee_id) do update set name = excluded.name
where name <> 'John Doe';
To specify these conditions in Drizzle, you can use setWhere and targetWhere clauses:

await db.insert(employees)
  .values({ employeeId: 123, name: 'John Doe' })
  .onConflictDoUpdate({
    target: employees.employeeId,
    targetWhere: sql`name <> 'John Doe'`,
    set: { name: sql`excluded.name` }
  });
await db.insert(employees)
  .values({ employeeId: 123, name: 'John Doe' })
  .onConflictDoUpdate({
    target: employees.employeeId,
    set: { name: 'John Doe' },
    setWhere: sql`name <> 'John Doe'`
  });
Upsert with composite indexes, or composite primary keys for onConflictDoUpdate:

await db.insert(users)
  .values({ firstName: 'John', lastName: 'Doe' })
  .onConflictDoUpdate({
    target: [users.firstName, users.lastName],
    set: { firstName: 'John1' }
  });
On duplicate key update
PostgreSQL
SQLite
MySQL
MySQL supports ON DUPLICATE KEY UPDATE instead of ON CONFLICT clauses. MySQL will automatically determine the conflict target based on the primary key and unique indexes, and will update the row if any unique index conflicts.

Drizzle supports this through the onDuplicateKeyUpdate method:

// Note that MySQL automatically determines targets based on the primary key and unique indexes
await db.insert(users)
  .values({ id: 1, name: 'John' })
  .onDuplicateKeyUpdate({ set: { name: 'John' } });
While MySQL does not directly support doing nothing on conflict, you can perform a no-op by setting any column’s value to itself and achieve the same effect:

import { sql } from 'drizzle-orm';
await db.insert(users)
  .values({ id: 1, name: 'John' })
  .onDuplicateKeyUpdate({ set: { id: sql`id` } });
WITH INSERT clause
Check how to use WITH statement with select, update, delete

Using the with clause can help you simplify complex queries by splitting them into smaller subqueries called common table expressions (CTEs):


const userCount = db.$with('user_count').as(
  db.select({ value: sql`count(*)`.as('value') }).from(users)
);
const result = await db.with(userCount)
  .insert(users)
  .values([
    { username: 'user1', admin: sql`((select * from ${userCount}) = 0)` }
  ])
  .returning({
    admin: users.admin
  });
with "user_count" as (select count(*) as "value" from "users") 
insert into "users" ("username", "admin") 
values ($1, ((select * from "user_count") = 0)) 
returning "admin"


SQL Update

await db.update(users)
  .set({ name: 'Mr. Dan' })
  .where(eq(users.name, 'Dan'));
The object that you pass to update should have keys that match column names in your database schema. Values of undefined are ignored in the object: to set a column to null, pass null. You can pass SQL as a value to be used in the update object, like this:


await db.update(users)
  .set({ updatedAt: sql`NOW()` })
  .where(eq(users.name, 'Dan'));
Update with returning
PostgreSQL
SQLite
MySQL
You can update a row and get it back in PostgreSQL and SQLite:


const updatedUserId: { updatedId: number }[] = await db.update(users)
  .set({ name: 'Mr. Dan' })
  .where(eq(users.name, 'Dan'))
  .returning({ updatedId: users.id });
WITH UPDATE clause
Check how to use WITH statement with select, insert, delete

Using the with clause can help you simplify complex queries by splitting them into smaller subqueries called common table expressions (CTEs):


const averagePrice = db.$with('average_price').as(
        db.select({ value: sql`avg(${products.price})`.as('value') }).from(products)
);
const result = await db.with(averagePrice)
    .update(products)
    .set({
      cheap: true
    })
    .where(lt(products.price, sql`(select * from ${averagePrice})`))
    .returning({
      id: products.id
    });
with "average_price" as (select avg("price") as "value" from "products") 
update "products" set "cheap" = $1 
where "products"."price" < (select * from "average_price") 
returning "id"


SQL Delete
You can delete all rows in the table:


await db.delete(users);
And you can delete with filters and conditions:


await db.delete(users).where(eq(users.name, 'Dan'));
Delete with return
PostgreSQL
SQLite
MySQL
You can delete a row and get it back in PostgreSQL and SQLite:


const deletedUser = await db.delete(users)
  .where(eq(users.name, 'Dan'))
  .returning();
// partial return
const deletedUserIds: { deletedId: number }[] = await db.delete(users)
  .where(eq(users.name, 'Dan'))
  .returning({ deletedId: users.id });
WITH DELETE clause
Check how to use WITH statement with select, insert, update

Using the with clause can help you simplify complex queries by splitting them into smaller subqueries called common table expressions (CTEs):


const averageAmount = db.$with('average_amount').as(
  db.select({ value: sql`avg(${orders.amount})`.as('value') }).from(orders)
);
const result = await db
  .with(averageAmount)
  .delete(orders)
  .where(gt(orders.amount, sql`(select * from ${averageAmount})`))
  .returning({
    id: orders.id
  });
with "average_amount" as (select avg("amount") as "value" from "orders") 
delete from "orders" 
where "orders"."amount" > (select * from "average_amount") 
returning "id"


Filter and conditional operators
We natively support all dialect specific filter and conditional operators.

You can import all filter & conditional from drizzle-orm:


import { eq, ne, gt, gte, ... } from "drizzle-orm";
eq
PostgreSQL
MySQL
SQLite
Value equal to n


import { eq } from "drizzle-orm";
db.select().from(table).where(eq(table.column, 5));

SELECT * FROM table WHERE table.column = 5
import { eq } from "drizzle-orm";
db.select().from(table).where(eq(table.column1, table.column2));
SELECT * FROM table WHERE table.column1 = table.column2
ne
PostgreSQL
MySQL
SQLite
Value is not equal to n

import { ne } from "drizzle-orm";
db.select().from(table).where(ne(table.column, 5));
SELECT * FROM table WHERE table.column <> 5
import { ne } from "drizzle-orm";
db.select().from(table).where(ne(table.column1, table.column2));
SELECT * FROM table WHERE table.column1 <> table.column2
gt
PostgreSQL
MySQL
SQLite
Value is greater than n

import { gt } from "drizzle-orm";
db.select().from(table).where(gt(table.column, 5));
SELECT * FROM table WHERE table.column > 5
import { gt } from "drizzle-orm";
db.select().from(table).where(gt(table.column1, table.column2));
SELECT * FROM table WHERE table.column1 > table.column2
gte
PostgreSQL
MySQL
SQLite
Value is greater than or equal to n

import { gte } from "drizzle-orm";
db.select().from(table).where(gte(table.column, 5));
SELECT * FROM table WHERE table.column >= 5
import { gte } from "drizzle-orm";
db.select().from(table).where(gte(table.column1, table.column2));
SELECT * FROM table WHERE table.column1 >= table.column2
lt
PostgreSQL
MySQL
SQLite
Value is less than n

import { lt } from "drizzle-orm";
db.select().from(table).where(lt(table.column, 5));
SELECT * FROM table WHERE table.column < 5
import { lt } from "drizzle-orm";
db.select().from(table).where(lt(table.column1, table.column2));
SELECT * FROM table WHERE table.column1 < table.column2
lte
PostgreSQL
MySQL
SQLite
Value is less than or equal to n.

import { lte } from "drizzle-orm";
db.select().from(table).where(lte(table.column, 5));
SELECT * FROM table WHERE table.column <= 5
import { lte } from "drizzle-orm";
db.select().from(table).where(lte(table.column1, table.column2));
SELECT * FROM table WHERE table.column1 <= table.column2
isNull
PostgreSQL
MySQL
SQLite
Value is null

import { isNull } from "drizzle-orm";
db.select().from(table).where(isNull(table.column));
SELECT * FROM table WHERE table.column IS NULL
isNotNull
PostgreSQL
MySQL
SQLite
Value is not null

import { isNotNull } from "drizzle-orm";
db.select().from(table).where(isNotNull(table.column));
SELECT * FROM table WHERE table.column IS NOT NULL
inArray
PostgreSQL
MySQL
SQLite
Value is in array of values

import { inArray } from "drizzle-orm";
db.select().from(table).where(inArray(table.column, [1, 2, 3, 4]));
SELECT * FROM table WHERE table.column in (1, 2, 3, 4)
import { inArray } from "drizzle-orm";
const query = db.select({ data: table2.column }).from(table2);
db.select().from(table).where(inArray(table.column, query));
SELECT * FROM table WHERE table.column IN (SELECT table2.column FROM table2)
notInArray
PostgreSQL
MySQL
SQLite
Value is not in array of values

import { notInArray } from "drizzle-orm";
db.select().from(table).where(notInArray(table.column, [1, 2, 3, 4]));
SELECT * FROM table WHERE table.column NOT in (1, 2, 3, 4)
import { notInArray } from "drizzle-orm";
const query = db.select({ data: table2.column }).from(table2);
db.select().from(table).where(notInArray(table.column, query));
SELECT * FROM table WHERE table.column NOT IN (SELECT table2.column FROM table2)
exists
PostgreSQL
MySQL
SQLite
Value exists

import { exists } from "drizzle-orm";
const query = db.select().from(table2)
db.select().from(table).where(exists(query));
SELECT * FROM table WHERE EXISTS (SELECT * from table2)
notExists
import { notExists } from "drizzle-orm";
const query = db.select().from(table2)
db.select().from(table).where(notExists(query));
SELECT * FROM table WHERE NOT EXISTS (SELECT * from table2)
between
PostgreSQL
MySQL
SQLite
Value is between two values

import { between } from "drizzle-orm";
db.select().from(table).where(between(table.column, 2, 7));
SELECT * FROM table WHERE table.column BETWEEN 2 AND 7
notBetween
PostgreSQL
MySQL
SQLite
Value is not between two value

import { notBetween } from "drizzle-orm";
db.select().from(table).where(notBetween(table.column, 2, 7));
SELECT * FROM table WHERE table.column NOT BETWEEN 2 AND 7
like
PostgreSQL
MySQL
SQLite
Value is like other value, case sensitive

import { like } from "drizzle-orm";
db.select().from(table).where(like(table.column, "%llo wor%"));
SELECT * FROM table  WHERE table.column LIKE '%llo wor%'
ilike
PostgreSQL
MySQL
SQLite
Value is like some other value, case insensitive

import { ilike } from "drizzle-orm";
db.select().from(table).where(ilike(table.column, "%llo wor%"));
SELECT * FROM table WHERE table.column ILIKE '%llo wor%'
notIlike
PostgreSQL
MySQL
SQLite
Value is not like some other value, case insensitive

import { notIlike } from "drizzle-orm";
db.select().from(table).where(notIlike(table.column, "%llo wor%"));
SELECT * FROM table WHERE table.column NOT ILIKE '%llo wor%'
not
PostgreSQL
MySQL
SQLite
All conditions must return false.

import { eq, not } from "drizzle-orm";
db.select().from(table).where(not(eq(table.column, 5)));
SELECT * FROM table WHERE NOT (table.column = 5)
and
PostgreSQL
MySQL
SQLite
All conditions must return true.

import { gt, lt, and } from "drizzle-orm";
db.select().from(table).where(and(gt(table.column, 5), lt(table.column, 7)));
SELECT * FROM table WHERE (table.column > 5 AND table.column < 7)
or
PostgreSQL
MySQL
SQLite
One or more conditions must return true.

import { gt, lt, or } from "drizzle-orm";
db.select().from(table).where(or(gt(table.column, 5), lt(table.column, 7)));
SELECT * FROM table WHERE (table.column > 5 OR table.column < 7)
arrayContains
PostgreSQL
MySQL
SQLite
Test that a column or expression contains all elements of the list passed as the second argument

import { arrayContains } from "drizzle-orm";
const contains = await db.select({ id: posts.id }).from(posts)
  .where(arrayContains(posts.tags, ['Typescript', 'ORM']));
const withSubQuery = await db.select({ id: posts.id }).from(posts)
  .where(arrayContains(
    posts.tags,
    db.select({ tags: posts.tags }).from(posts).where(eq(posts.id, 1)),
  ));
select "id" from "posts" where "posts"."tags" @> {Typescript,ORM};
select "id" from "posts" where "posts"."tags" @> (select "tags" from "posts" where "posts"."id" = 1);
arrayContained
PostgreSQL
MySQL
SQLite
Test that the list passed as the second argument contains all elements of a column or expression

import { arrayContained } from "drizzle-orm";
const contained = await db.select({ id: posts.id }).from(posts)
  .where(arrayContained(posts.tags, ['Typescript', 'ORM']));
select "id" from "posts" where "posts"."tags" <@ {Typescript,ORM};
arrayOverlaps
PostgreSQL
MySQL
SQLite
Test that a column or expression contains any elements of the list passed as the second argument.

import { arrayOverlaps } from "drizzle-orm";
const overlaps = await db.select({ id: posts.id }).from(posts)
  .where(arrayOverlaps(posts.tags, ['Typescript', 'ORM']));
select "id" from "posts" where "posts"."tags" && {Typescript,ORM}


Joins [SQL]
Join clause in SQL is used to combine 2 or more tables, based on related columns between them. Drizzle ORM joins syntax is a balance between the SQL-likeness and type safety.

Join types
Drizzle ORM has APIs for INNER JOIN, FULL JOIN, LEFT JOIN and RIGHT JOIN. Lets have a quick look at examples based on below table schemas:


export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
});
export const pets = pgTable('pets', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
  ownerId: integer('owner_id').notNull().references(() => users.id),
})
Left Join

const result = await db.select().from(users).leftJoin(pets, eq(users.id, pets.ownerId))
select ... from "users" left join "pets" on "users"."id" = "pets"."owner_id"
// result type
const result: {
    user: {
        id: number;
        name: string;
    };
    pets: {
        id: number;
        name: string;
        ownerId: number;
    } | null;
}[];
Right Join

const result = await db.select().from(users).rightJoin(pets, eq(users.id, pets.ownerId))
select ... from "users" right join "pets" on "users"."id" = "pets"."owner_id"
// result type
const result: {
    user: {
        id: number;
        name: string;
    } | null;
    pets: {
        id: number;
        name: string;
        ownerId: number;
    };
}[];
Inner Join

const result = await db.select().from(users).innerJoin(pets, eq(users.id, pets.ownerId))
select ... from "users" inner join "pets" on "users"."id" = "pets"."owner_id"
// result type
const result: {
    user: {
        id: number;
        name: string;
    };
    pets: {
        id: number;
        name: string;
        ownerId: number;
    };
}[];
Full Join

const result = await db.select().from(users).fullJoin(pets, eq(users.id, pets.ownerId))
select ... from "users" full join "pets" on "users"."id" = "pets"."owner_id"
// result type
const result: {
    user: {
        id: number;
        name: string;
    } | null;
    pets: {
        id: number;
        name: string;
        ownerId: number;
    } | null;
}[];
Partial select
If you need to select a particular subset of fields or to have a flat response type, Drizzle ORM supports joins with partial select and will automatically infer return type based on .select({ ... }) structure.


await db.select({
  userId: users.id,
  petId: pets.id,
}).from(user).leftJoin(pets, eq(users.id, pets.ownerId))
select "users"."id", "pets"."id" from "users" left join "pets" on "users"."id" = "pets"."owner_id"
// result type
const result: {
  userId: number;
  petId: number | null;
}[];
You might’ve noticed that petId can be null now, it’s because we’re left joining and there can be users without a pet.

It’s very important to keep in mind when using sql operator for partial selection fields and aggregations when needed, you should to use sql<type | null> for proper result type inference, that one is on you!


const result = await db.select({
  userId: users.id,
  petId: pets.id,
  petName1: sql`upper(${pets.name})`,
  petName2: sql<string | null>`upper(${pets.name})`,
  //˄we should explicitly tell 'string | null' in type, since we're left joining that field
}).from(user).leftJoin(pets, eq(users.id, pets.ownerId))
select "users"."id", "pets"."id", upper("pets"."name")... from "users" left join "pets" on "users"."id" = "pets"."owner_id"
// result type
const result: {
  userId: number;
  petId: number | null;
  petName1: unknown;
  petName2: string | null;
}[];
To avoid plethora of nullable fields when joining tables with lots of columns we can utilise our nested select object syntax, our smart type inference will make whole object nullable instead of making all table fields nullable!


await db.select({
  userId: users.id,
  userName: users.name,
  pet: {
    id: pets.id,
    name: pets.name,
    upperName: sql<string>`upper(${pets.name})`
  }
}).from(user).fullJoin(pets, eq(users.id, pets.ownerId))
select ... from "users" full join "pets" on "users"."id" = "pets"."owner_id"
// result type
const result: {
    userId: number | null;
    userName: string | null;
    pet: {
        id: number;
        name: string;
        upperName: string;
    } | null;
}[];
Aliases & Selfjoins
Drizzle ORM supports table aliases which comes really handy when you need to do selfjoins.

Lets say you need to fetch users with their parents:


import { user } from "./schema";
const parent = aliasedTable(user, "parent")
const result = db
  .select()
  .from(user)
  .leftJoin(parent, eq(parent.id, user.parentId));
select ... from "user" left join "user" "parent" on "parent"."id" = "user"."parent_id"
// result type
const result: {
    user: {
        id: number;
        name: string;
        parentId: number;
    };
    parent: {
        id: number;
        name: string;
        parentId: number;
    } | null;
}[];
Aggregating results
Drizzle ORM delivers name-mapped results from the driver without changing the structure.

You’re free to operate with results the way you want, here’s an example of mapping many-one relational data:

type User = typeof users.$inferSelect;
type Pet = typeof pets.$inferSelect;
const rows = db.select({
    user: users,
    pet: pets,
  }).from(users).leftJoin(pets, eq(users.id, pets.ownerId)).all();
const result = rows.reduce<Record<number, { user: User; pets: Pet[] }>>(
  (acc, row) => {
    const user = row.user;
    const pet = row.pet;
    if (!acc[user.id]) {
      acc[user.id] = { user, pets: [] };
    }
    if (pet) {
      acc[user.id].pets.push(pet);
    }
    return acc;
  },
  {}
);
// result type
const result: Record<number, {
    user: User;
    pets: Pet[];
}>;
Many-to-one example
import { sqliteTable, text, integer } from 'drizzle-orm/sqlite-core';
import { drizzle } from 'drizzle-orm/better-sqlite3';
const cities = sqliteTable('cities', {
  id: integer('id').primaryKey(),
  name: text('name'),
});
const users = sqliteTable('users', {
  id: integer('id').primaryKey(),
  name: text('name'),
  cityId: integer('city_id').references(() => cities.id)
});
const db = drizzle(sqlite);
const result = db.select().from(cities).leftJoin(users, eq(cities.id, users.cityId)).all();
Many-to-many example
const users = sqliteTable('users', {
  id: integer('id').primaryKey(),
  name: text('name'),
});
const chatGroups = sqliteTable('chat_groups', {
  id: integer('id').primaryKey(),
  name: text('name'),
});
const usersToChatGroups = sqliteTable('usersToChatGroups', {
  userId: integer('user_id').notNull().references(() => users.id),
  groupId: integer('group_id').notNull().references(() => chatGroups.id),
});
// querying user group with id 1 and all the participants(users)
db.select()
  .from(usersToChatGroups)
  .leftJoin(users, eq(usersToChatGroups.userId, users.id))
  .leftJoin(chatGroups, eq(usersToChatGroups.groupId, chatGroups.id))
  .where(eq(chatGroups.id, 1))
  .all();